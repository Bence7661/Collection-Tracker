--[[
    /------< Collection Tracker >--------\
    |   Creator:     SERIOUS             |
    |   Mod:         Collection Tracker  |
    |   Version:     v1.0.0              |
    |   Created:     03.24.2025          |
    |   Last edit:	 03.29.2025          |
    \------------------------------------/

    inventory 
    {
        {
            obj_id = 1,
            name = "M4"
            obj_section = "wpn_brn180"
            isPersistent = true
            isInBox = false
            parts = 
            {
                {
                    name = "Gas tube"
                    cond = 25
                    cond_txt = "25%"
                },
                {
                    name = "Barrel"
                    cond = 20
                    cond_txt = "20%"
                }
            }
        }
    }
--]]

local inventory = {}
local droppedEntryItemCache = {}
local delayedMarkInventoryEntryPersistentEvents = 0

function TakeIntoInventory(obj)
    if not obj then
        return
    end
  
    local objParts = item_parts.get_parts_con(obj)
    local partsUi = {}
    local id = obj:id()
    local section = obj:section()
    local uiSection = ui_item.get_sec_name(section)

    local parent = obj:parent() -- Basically the owner of the item.
    local isInsideBox = parent and IsInvbox(parent) or false
    local refreshPartsBeforeAccess = parent and parent:id() == db.actor:id() or false

    if objParts then
        for prtName, cond in pairs(objParts) do
            local uiPartName = ui_item.get_sec_name(prtName)
            if uiPartName ~= ui_item.get_sec_name(section) then
                partsUi[#partsUi + 1] =
                {
                    name = uiPartName,
                    cond = cond,
                    cond_txt = tostring(cond) .. "%"
                }
            end
        end
    end

    inventory[uiSection] =
    {
        obj_ref = obj,
        obj_id = id,
        name = uiSection, -- Also dictionary key. Will be useful if I iterate with "for"
        obj_section = section,
        isPersistent = true,
        isInBox = isInsideBox,
        parts = partsUi,
        refreshPartsBeforeAccess = refreshPartsBeforeAccess
    }
end

function BatchTakeIntoInventory(stash)
    -- Consider duplicates!!
    local registerQueue = {}

    -- Maybe I should modify the calculation of the "winner".
    -- Right now if there are 2 items
    -- 1 with many low cond part 
    -- one with all 1% parts except 1 part that is 100% 
    -- I think I'll just take the average condition of parts and then add it to the score as well. Or average and median.
    local function collectBest(_, item)
        if (IsWeapon(item)) or (IsOutfit(item) or IsHeadgear(item)) or (item:section() == "wpn_upd") then --KNIVES WILL CRASH THIS
            local registeredInvItem = GetInventoryItemEntryByUiName(item)
            if item:id() ~= (registeredInvItem and registeredInvItem.obj_id) then
                    
                local uiName = ui_item.get_sec_name(item:section())
                local contestantItem1 =
                {
                    itmObj = item or nil,
                    score = -1
                }
                local contestantItem2 =
                {
                    itmObj = registeredInvItem and registeredInvItem.obj_ref or registerQueue[uiName].itmObj or nil,
                    score = -1
                }
        
                local tempScore = 0
                local objParts = item_parts.get_parts_con(item)
                if objParts then
                    for prtName, cond in pairs(objParts) do
                        local uiPartName = ui_item.get_sec_name(prtName)
                        if uiPartName ~= ui_item.get_sec_name(item:section()) then
                            tempScore = tempScore + cond
                        end
                    end
                    
                    contestantItem1.score = tempScore
                end
                
                if contestantItem2.itmObj then
                    tempScore = 0
                    objParts = item_parts.get_parts_con(contestantItem2.itmObj)
                    if objParts then
                        for prtName, cond in pairs(objParts) do
                            local uiPartName = ui_item.get_sec_name(prtName)
                            if uiPartName ~= ui_item.get_sec_name(item:section()) then
                                tempScore = tempScore + cond
                            end
                        end
                    end

                    contestantItem2.score = tempScore
                else
                    contestantItem2 = registerQueue[uiName]
                end
        
                if contestantItem2 and contestantItem2.score > contestantItem1.score then
                    registerQueue[uiName] = contestantItem2
                else
                    TakeFromInventory(item:section()) -- Idempotent
                    registerQueue[uiName] = contestantItem1
                end
            end

        end
    end

    stash:iterate_inventory_box(collectBest, nil)

    for _, queueItem in pairs(registerQueue) do
        TakeIntoInventory(queueItem.itmObj)
    end
end

function TakeFromInventory(section)
    if not section then
        return
    end

    local compSection = ui_item.get_sec_name(section)
    inventory[compSection] = nil
end

function OverWriteInventoryItem(obj)
    local item = GetInventoryItemEntryByUiName(obj)

    local objParts = item_parts.get_parts_con(obj)
    local partsUi = {}
    local id = obj:id()
    local section = obj:section()

    local parent = obj:parent() -- Basically the owner of the item.
    local isInsideBox = parent and IsInvbox(parent) or false
    local refreshPartsBeforeAccess = parent and parent:id() == db.actor:id() or false

    if objParts then
        for prtName, cond in pairs(objParts) do
            local uiPartName = ui_item.get_sec_name(prtName)
            if uiPartName ~= ui_item.get_sec_name(section) then
                partsUi[#partsUi + 1] =
                {
                    name = uiPartName,
                    cond = cond,
                    cond_txt = tostring(cond) .. "%"
                }
            end
        end
    end

    item.obj_ref = obj
    item.obj_id = id
    item.obj_section = section
    item.isPersistent = true
    item.isInBox = isInsideBox
    item.parts = partsUi
    item.refreshPartsBeforeAccess = refreshPartsBeforeAccess
end

function GetInventory()
    return inventory
end

function IsInInventory(section)
    local compSection = ui_item.get_sec_name(section)
    return inventory[compSection] ~= nil
end

function IsExactItemInInventory(obj)
    local item = GetInventoryItemEntryByUiName(obj)
    if item ~= nil and item.obj_id == obj:id() then
        return true
    end

    return false
end

function GetExactInventoryItemEntry(obj)
    if not obj then
        return nil
    end
    
    local entry = GetInventoryItemEntryByUiName(obj)
    if entry ~= nil and entry.obj_id == obj:id() then
        return entry
    end
    
    return nil
end

function GetInventoryItemEntryByUiName(obj)
    if not obj then
        return nil
    end
    
    local compSection = ui_item.get_sec_name(obj:section())
    local entry = inventory[compSection]
    return entry
end

function RefreshEntryParts(entry)
    local item = entry.obj_ref

    if not item then
        return
    end

    local staticParts = item_parts.get_parts_con(item)
    for staticPrtName, staticCond in pairs(staticParts) do
        for i, part in ipairs(entry.parts) do
            if part.name == ui_item.get_sec_name(staticPrtName) then
                entry.parts[i].cond = staticCond
                entry.parts[i].cond_txt = tostring(staticCond) .. "%"
            end
        end
    end
end

function GetEntryParts(entry)
    if not entry then
        return
    end

    if entry.refreshPartsBeforeAccess then RefreshEntryParts(entry) end
    return entry.parts
end

local function save_state(m_data)
	if (USE_MARSHAL) then
		if (not m_data.pda_inventory_tracker) then
			m_data.pda_inventory_tracker = {}
		end
		m_data.pda_inventory_tracker.inventory_entries = inventory
	end
end

local function load_state(m_data)
	if (USE_MARSHAL) then
		if (not m_data.pda_inventory_tracker) then
			return
		end
		inventory = m_data.pda_inventory_tracker.inventory_entries or {}
	end
end

--The actor_on_trade does not trigger for some reason. 
--For me it's fine because actually the dropping check triggers so the item gets the non persistent flag.
function LoseInventoryEntry(obj, _, _)
    if IsExactItemInInventory(obj) then
        TakeFromInventory(obj:section())
    end
end

function ValidateInventoryEntries()
    for _, entry in pairs(inventory) do
        if not entry.isPersistent then
            TakeFromInventory(entry.obj_section)
        end
    end
end

function ValidateAgainstCache(obj)
    if not IsWeapon(obj) and not IsOutfit(obj) and not IsHeadgear(obj) and obj:section() ~= "wpn_upd" then -- Ignore anything unrelated.
        return
    end

    if droppedEntryItemCache and droppedEntryItemCache.parts then
        local inventoryItem = GetExactInventoryItemEntry(droppedEntryItemCache)
        if inventoryItem and inventoryItem.parts then
            --I don't check `entry.refreshParts` here. I should refresh regardless.
            droppedEntryItemCache:refreshParts()
            inventoryItem:refreshParts()
            
            local matches = 0
            for _, invItemPart in pairs(inventoryItem.parts) do
                for _, cacheItemPart in pairs(droppedEntryItemCache.parts) do
                    if invItemPart.name == cacheItemPart.name and invItemPart.cond == cacheItemPart.cond then
                        matches = matches + 1
                    end
                end
            end

            if matches == #inventoryItem.parts then
                inventoryItem.obj_id = obj:id()
                inventoryItem.isPersistent = true
            end
        end
    end
end

function MarkInventoryEntryPersistent(obj)
    local entry = GetExactInventoryItemEntry(obj)

    ValidateAgainstCache(obj)

    if entry then
        entry.isPersistent = true
    end

    delayedMarkInventoryEntryPersistentEvents = delayedMarkInventoryEntryPersistentEvents - 1
    return true
end

function DelayedMarkInventoryEntryPersistent(obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    CreateTimeEvent("inventory_tracker", "delay_MarkInventoryEntryPersistent_" .. delayedMarkInventoryEntryPersistentEvents, 0.1, MarkInventoryEntryPersistent, obj)
    delayedMarkInventoryEntryPersistentEvents = delayedMarkInventoryEntryPersistentEvents + 1
end

function DeleteDroppedEntryItemCache()
    droppedEntryItemCache = nil
    return true
end

function MarkInventoryEntryNonPersistent(obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    local entry = GetExactInventoryItemEntry(obj)
    if (IsWeapon(obj)) or (IsOutfit(obj) or IsHeadgear(obj)) or (obj:section() == "wpn_upd") then -- Make sure we don't cache attachments.
        if entry and not entry.isInBox then
            entry.isPersistent = false
            droppedEntryItemCache = entry
            CreateTimeEvent("inventory_tracker", "DeleteDroppedEntryItemCache", 0.3, DeleteDroppedEntryItemCache)
        end
    end

    return true
end

function DynamicCondition(obj)
    local entry = GetExactInventoryItemEntry(obj)
    if not entry then
        return
    end

    entry.refreshPartsBeforeAccess = true
end

function RipDynamicCondition(obj)
    local entry = GetExactInventoryItemEntry(obj)
    if not entry then
        return
    end

    GetEntryParts(entry) -- Refreshes parts if `refreshPartsBeforeAccess` is true.
    entry.refreshPartsBeforeAccess = false
end

local function ItemPutToBox(_, obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    local objId = obj:id()
    local entry = GetExactInventoryItemEntry(obj)
    if entry and entry.obj_id == objId then
        entry.isInBox = true
    end
end

local function ItemTakenFromBox(_, obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    local objId = obj:id()
    local entry = GetExactInventoryItemEntry(obj)
    if entry and entry.obj_id == objId then
        entry.isInBox = false
    end
end

-- Debug function.
-- local function FlushInventory(key)
--     if key == DIK_keys.DIK_X then
--         FileLogger.log("Flushing inventory")
        
--         inventory = {}
--         droppedEntryItemCache = {}
--     end
-- end

-- local function RandomPartsCondForInvWeapons(key)
--     if key == DIK_keys.DIK_C then
--         FileLogger.log("Randomizing weapon part conditions")

--         db.actor:iterate_inventory(function(_, item)
--             if not IsMelee(item) and IsWeapon(item) then
--                 local parts = item_parts.get_parts_con(item)

--                 for name, _ in pairs(parts) do
--                     parts[name] = math.random(1, 100)
--                 end

--                 item_parts.set_parts_con(item:id(), parts)
--             end
--         end, nil)
--     end
-- end

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_trade", LoseInventoryEntry) --
    RegisterScriptCallback("on_level_changing", ValidateInventoryEntries)
    RegisterScriptCallback("actor_on_item_drop", MarkInventoryEntryNonPersistent)
    RegisterScriptCallback("actor_on_item_take", DelayedMarkInventoryEntryPersistent)
    RegisterScriptCallback("actor_on_item_put_in_box", ItemPutToBox)
    RegisterScriptCallback("actor_on_item_take_from_box", ItemTakenFromBox)
    
    -- Everything else should turn off dynamic condition.
    RegisterScriptCallback("actor_on_item_take", DynamicCondition) -- ON
    RegisterScriptCallback("actor_on_item_drop", RipDynamicCondition) -- OFF

    -- Debug stuff.
    -- RegisterScriptCallback("on_key_press", FlushInventory)
    -- RegisterScriptCallback("on_key_press", RandomPartsCondForInvWeapons)
end