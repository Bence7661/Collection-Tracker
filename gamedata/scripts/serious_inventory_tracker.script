--[[
    /------< Collection Tracker >--------\
    |   Creator:     SERIOUS             |
    |   Mod:         Collection Tracker  |
    |   Version:     v1.0.0              |
    |   Created:     03.24.2025          |
    |   Last edit:	 03.29.2025          |
    \------------------------------------/

    inventory 
    {
        {
            obj_id = 1,
            name = "M4"
            obj_section = "wpn_brn180"
            isPersistent = true
            isInBox = false
            parts = 
            {
                {
                    name = "Gas tube"
                    cond = 25
                    cond_txt = "25%"
                },
                {
                    name = "Barrel"
                    cond = 20
                    cond_txt = "20%"
                }
            }
        }
    }
--]]

local inventory = {}
local droppedEntryItemCache = {}
local delayedMarkInventoryEntryPersistentEvents = 0

function TakeIntoInventory(obj)
    if not obj then
        return
    end
  
    local objParts = item_parts.get_parts_con(obj)
    local partsUi = {}
    local id = obj:id()
    local section = obj:section()
    local uiSection = ui_item.get_sec_name(section)
    local refreshPartsBeforeAccess = false

    local parent = obj:parent() -- Basically the owner of the item.
    local isInsideBox = parent and IsInvbox(parent) or false

    if objParts then
        for prtName, cond in pairs(objParts) do
            local uiPartName = ui_item.get_sec_name(prtName)
            if uiPartName ~= ui_item.get_sec_name(section) then
                partsUi[#partsUi + 1] =
                {
                    name = uiPartName,
                    cond = cond,
                    cond_txt = tostring(cond) .. "%"
                }
            end
        end
    end

    local owner = obj:parent()

    if owner and owner:id() == db.actor:id() then
        refreshPartsBeforeAccess = true
    end

    inventory[uiSection] =
    {
        obj_ref = obj,
        obj_id = id,
        name = uiSection, -- Also dictionary key. Will be useful if I iterate with "for"
        obj_section = section,
        isPersistent = true,
        isInBox = isInsideBox,
        parts = partsUi,
        refreshPartsBeforeAccess = refreshPartsBeforeAccess
    }
end

function TakeFromInventory(section)
    if not section then
        return
    end
    local compSection = ui_item.get_sec_name(section)
    
    inventory[compSection] = nil
end

function OverWriteInventoryItem(obj)
    local item = GetInventoryItemEntryByUiName(obj)

    local objParts = item_parts.get_parts_con(obj)
    local partsUi = {}
    local id = obj:id()
    local section = obj:section()
    local refreshPartsBeforeAccess = false

    local parent = obj:parent() -- Basically the owner of the item.
    local isInsideBox = parent and IsInvbox(parent) or false

    if objParts then
        for prtName, cond in pairs(objParts) do
            local uiPartName = ui_item.get_sec_name(prtName)
            if uiPartName ~= ui_item.get_sec_name(section) then
                partsUi[#partsUi + 1] =
                {
                    name = uiPartName,
                    cond = cond,
                    cond_txt = tostring(cond) .. "%"
                }
            end
        end
    end

    local owner = obj:parent()
    if owner and owner:id() == db.actor:id() then
        refreshPartsBeforeAccess = true
    end

    item.obj_ref = obj
    item.obj_id = id
    item.obj_section = section
    item.isPersistent = true
    item.isInBox = isInsideBox
    item.parts = partsUi
    item.refreshPartsBeforeAccess = refreshPartsBeforeAccess
end

function GetInventory()
    return inventory
end

function IsInInventory(section)
    local compSection = ui_item.get_sec_name(section)

    return inventory[compSection] ~= nil
end

function IsExactItemInInventory(obj)
    local item = GetInventoryItemEntryByUiName(obj)

    if item ~= nil and item.obj_id == obj:id() then
        return true
    end

    return false
end

function GetExactInventoryItemEntry(obj)
    if not obj then
        return nil
    end
    
    local entry = GetInventoryItemEntryByUiName(obj)
    
    if entry ~= nil and entry.obj_id == obj:id() then
        return entry
    end
    
    return nil
end

function GetInventoryItemEntryByUiName(obj)
    if not obj then
        return nil
    end
    
    local compSection = ui_item.get_sec_name(obj:section())
    local entry = inventory[compSection]
    
    return entry
end

function RefreshEntryParts(entry)
    local item = entry.obj_ref

    if not item then
        return
    end

    local staticParts = item_parts.get_parts_con(item)

    for staticPrtName, staticCond in pairs(staticParts) do
        for i, part in ipairs(entry.parts) do
            if part.name == ui_item.get_sec_name(staticPrtName) then
                entry.parts[i].cond = staticCond
                entry.parts[i].cond_txt = tostring(staticCond) .. "%"
            end
        end
    end
end

function GetEntryParts(entry)
    if not entry then
        return
    end

    if entry.refreshPartsBeforeAccess then RefreshEntryParts(entry) end
    return entry.parts
end

local function save_state(m_data)
	if (USE_MARSHAL) then
		if (not m_data.pda_inventory_tracker) then
			m_data.pda_inventory_tracker = {}
		end
		m_data.pda_inventory_tracker.inventory_entries = inventory
	end
end

local function load_state(m_data)
	if (USE_MARSHAL) then
		if (not m_data.pda_inventory_tracker) then
			return
		end
		inventory = m_data.pda_inventory_tracker.inventory_entries or {}
	end
end

--The actor_on_trade does not trigger for some reason. 
--For me it's fine because actually the dropping check triggers so the item gets the non persistent flag.
function LoseInventoryEntry(obj, _, _)
    if IsExactItemInInventory(obj) then
        TakeFromInventory(obj:section())
    end
end

function ValidateInventoryEntries()
    for _, entry in pairs(inventory) do
        if not entry.isPersistent then
            TakeFromInventory(entry.obj_section)
        end
    end
end

function ValidateAgainstCache(obj)
    if not IsWeapon(obj) and not IsOutfit(obj) and not IsHeadgear(obj) and obj:section() ~= "wpn_upd" then -- Ignore anything unrelated.
        return
    end

    if droppedEntryItemCache and droppedEntryItemCache.parts then
        local inventoryItem = GetExactInventoryItemEntry(droppedEntryItemCache)
        
        if inventoryItem and inventoryItem.parts then
            --I don't check `entry.refreshParts` here. I should refresh regardless.
            droppedEntryItemCache:refreshParts()
            inventoryItem:refreshParts()
            
            local matches = 0
            for _, invItemPart in pairs(inventoryItem.parts) do
                for _, cacheItemPart in pairs(droppedEntryItemCache.parts) do
                    if invItemPart.name == cacheItemPart.name and invItemPart.cond == cacheItemPart.cond then
                        matches = matches + 1
                    end
                end
            end

            if matches == #inventoryItem.parts then
                inventoryItem.obj_id = obj:id()
                inventoryItem.isPersistent = true
            end
        end
    end
end

function MarkInventoryEntryPersistent(obj)
    local entry = GetExactInventoryItemEntry(obj)

    ValidateAgainstCache(obj)

    if entry then
        entry.isPersistent = true
    end

    delayedMarkInventoryEntryPersistentEvents = delayedMarkInventoryEntryPersistentEvents - 1
    return true
end

function DelayedMarkInventoryEntryPersistent(obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    CreateTimeEvent("inventory_tracker", "delay_MarkInventoryEntryPersistent_" .. delayedMarkInventoryEntryPersistentEvents, 0.1, MarkInventoryEntryPersistent, obj)
    delayedMarkInventoryEntryPersistentEvents = delayedMarkInventoryEntryPersistentEvents + 1
end

function DeleteDroppedEntryItemCache()
    droppedEntryItemCache = nil
    return true
end

function MarkInventoryEntryNonPersistent(obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    local entry = GetExactInventoryItemEntry(obj)
    if (IsWeapon(obj)) or (IsOutfit(obj) or IsHeadgear(obj)) or (obj:section() == "wpn_upd") then -- Make sure we don't cache attachments.
        if entry and not entry.isInBox then
            entry.isPersistent = false
            droppedEntryItemCache = entry
            CreateTimeEvent("inventory_tracker", "DeleteDroppedEntryItemCache", 0.3, DeleteDroppedEntryItemCache)
        end
    end

    return true
end

function DynamicCondition(obj)
    local entry = GetExactInventoryItemEntry(obj)
    if not entry then
        return
    end

    entry.refreshPartsBeforeAccess = true
end

function RipDynamicCondition(obj)
    local entry = GetExactInventoryItemEntry(obj)
    if not entry then
        return
    end

    GetEntryParts(entry) -- Refreshes parts if `refreshPartsBeforeAccess` is true.

    entry.refreshPartsBeforeAccess = false
end

local function ItemPutToBox(_, obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    local objId = obj:id()
    local entry = GetExactInventoryItemEntry(obj)
    
    if entry and entry.obj_id == objId then
        entry.isInBox = true
    end
end

local function ItemTakenFromBox(_, obj)
    if not IsExactItemInInventory(obj) then
        return
    end

    local objId = obj:id()
    local entry = GetExactInventoryItemEntry(obj)
    
    if entry and entry.obj_id == objId then
        entry.isInBox = false
    end
end

-- Debug function.
-- local function FlushInventory(key)
--     if key == DIK_keys.DIK_X then
--         FileLogger.log("Flushing inventory")

--         inventory = {}
--         droppedEntryItemCache = {}
--     end
-- end

function CustomUiBuildDescHeader(obj, sec, str)
    local originalText = str
    local injectedText = ""
    local injectedTextBegin = "Collection tracker: "
    local injectedTextEnd = " is recorded in inventory."
    local objectMetaInfo = ""
    local defColor = utils_xml.get_color("white", false)
    local color = defColor
    local newLinesBefore = ""
    local injectText = false

    if IsMelee(obj) then
        injectText = true
        objectMetaInfo = "CQC weapon"
        newLinesBefore = "\\n"
    elseif IsWeapon(obj) then
        injectText = true
        objectMetaInfo = "weapon"
        newLinesBefore = "\\n \\n"
    else
        newLinesBefore = "\\n"
    end
    
    if IsOutfit(obj) then
        injectText = true
        objectMetaInfo = "outfit"
    end
    if IsHeadgear(obj) then
        injectText = true
        objectMetaInfo = "headgear"
    end
    if obj:section() == "wpn_upd" then
        injectText = true
        objectMetaInfo = "unknown"
    end

    if IsExactItemInInventory(obj) then
        color = utils_xml.get_color("green", false)
        injectedText = defColor .. injectedTextBegin .. color .. " This " .. objectMetaInfo .. injectedTextEnd
    elseif IsInInventory(obj:section()) then
        color = utils_xml.get_color("yellow", false)
        injectedText = defColor .. injectedTextBegin .. color .. " Similar " .. objectMetaInfo .. injectedTextEnd
    else
        color = utils_xml.get_color("red", false)
        injectedText = defColor .. injectedTextBegin .. color .. " No records found."
    end

    if injectText then
        str = newLinesBefore .. injectedText .. "\\n \\n" .. defColor .. originalText
    end

    return UiOriginalBuildDescHeader(obj, sec, str)
end

function UiOriginalBuildDescHeader(obj, sec, str)
end

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_trade", LoseInventoryEntry) --
    RegisterScriptCallback("on_level_changing", ValidateInventoryEntries)
    RegisterScriptCallback("actor_on_item_drop", MarkInventoryEntryNonPersistent)
    RegisterScriptCallback("actor_on_item_take", DelayedMarkInventoryEntryPersistent)
    RegisterScriptCallback("actor_on_item_put_in_box", ItemPutToBox)
    RegisterScriptCallback("actor_on_item_take_from_box", ItemTakenFromBox)
    
    -- RegisterScriptCallback("on_key_press", FlushInventory)
    
    -- Everything else should turn off dynamic condition.
    RegisterScriptCallback("actor_on_item_take", DynamicCondition) -- ON
    RegisterScriptCallback("actor_on_item_drop", RipDynamicCondition) -- OFF

    UiOriginalBuildDescHeader = ui_item.build_desc_header
    ui_item.build_desc_header = CustomUiBuildDescHeader
end